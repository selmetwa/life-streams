package web

import (
	"fmt"
	db "life-streams/internal/database"
)

templ StreamsList(streams []db.Stream) {
	<ul class="streams" hx-trigger="newStream from:body" hx-get="/get_streams" hx-swap="outerHTML">
      <style>

      .empty {
        margin: 0;
        color: var(--text2);
        font-size: 1rem;
        font-weight: 500;
      }


         .streams {
            list-style-type: none;
      padding: 0;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 10px;
      flex-direction: column;
    }

        .stream-wrapper {
      padding: 1rem;
      background-color: var(--tile5);
      border: 1px solid var(--tile6);
      border-radius: 0.5rem;
      cursor: move;
      color: var(--text1);
    }
  </style>

    if len(streams) == 0 {
      <p class="empty">No streams found</p>
    } else {
		for _, stream := range streams {
			<li
				class="stream-wrapper"
				draggable="true"
				ondragover="dragOver(event)"
				ondragstart="dragStart(event)"
				ondragend="dragEnd(event)"
				ontouchstart="touchStart(event)"
				ontouchmove="touchMove(event)"
				ontouchend="touchEnd(event)"
			>
				<h3>{ stream.Title }</h3>
				<p>{ stream.Description }</p>
				<p>Tasks: { fmt.Sprintf("%d", stream.TasksCount) }</p>
			</li>
		}
    }


    <script>
      let selected = null

      function dragOver(e) {
        e.preventDefault();
        if (e.target.classList.contains('stream-wrapper') && e.target !== selected) {
          if (isBefore(selected, e.target)) {
            e.target.parentNode.insertBefore(selected, e.target);
          } else {
            e.target.parentNode.insertBefore(selected, e.target.nextSibling);
          }
        }
      }

      function dragEnd(e) {
        e.target.style.opacity = '1'

        selected = null
      }

      function dragStart(e) {
        console.log({ e })
        e.dataTransfer.effectAllowed = 'move'
        e.dataTransfer.setData('text/plain', null)
        selected = e.target
        selected.style.opacity = '0.4'
      }

      function touchStart(e) {
        selected = e.target.closest('.stream-wrapper');
      }

      function touchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY).closest('.stream-wrapper');
        if (target && target !== selected) {
          e.target.style.opacity = '0.4'
          if (isBefore(selected, target)) {
            target.parentNode.insertBefore(selected, target);
          } else {
            target.parentNode.insertBefore(selected, target.nextSibling);
          }
        }
      }

      function touchEnd(e) {
        e.target.style.opacity = '1'

        selected = null;
      }

      function isBefore(el1, el2) {
        let cur
        if (el2.parentNode === el1.parentNode) {
          for (cur = el1.previousSibling; cur; cur = cur.previousSibling) {
            if (cur === el2) return true
          }
        }
        return false;
      }
    </script>
	</ul>
}
